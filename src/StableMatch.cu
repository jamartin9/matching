// for cout
#include <iostream>
// for signal handlers
#include <signal.h>
// for string stream after reading from file
#include <sstream>
// for file stream
#include <fstream>
// c++ STL for string
#include <string>
// for printf()
#include <cstdio>
// for time()
#include <time.h>
// for thrust::min_element()
#include <thrust/extrema.h>
// for thrust pairs
#include <thrust/pair.h>

using namespace std;
//TODO:
// Find nm2 pairs
// Create new matching
// Add controlling logic
// Change find minimum to not use thrust and use kernel for rows and cols
// Make random number generation parallel
// Make file reading parallel
// Make matrix generation parallel
// Change Init_Phase(iniMatch) to use get final position by first thread to reach it instead of first thread in row
// Allocate n on GPU and pass pointer instead of passing by value
// Maybe change int Type to series of boolean values

// structure for each Processor Element
struct Element {
	// graph x value, column
	int x;
	// graph y value, row
	int y;
	// l value of the graph (e.g., man pref)
	int l;
	// r value of the graph (e.g., women pref)
	int r;
	// logical pointer to element
	int pointer;
	// type of the pair
	//   0: unmatched
	//   1: matched
	//   2: unstable
	//   3: nm_1-generating
	//   4: nm_1
	//   5: nm_2
	int type;
	// nm_2-generating
	bool nm2gen;
};

// first integer to hold element a, e.g. the man, 1 <= a <= n
// second integer to hold element b, e.g. the woman, 1 <= b <= n
thrust::pair<int, int> *matchingPairs;

// global state for stable matching
// true if no unstable matches exist, false otherwise
bool *stable;

// global counter for the number of lines/people
int n;

// function for printing pairs
void printPairs() {

	// check that n isn't 0
	if (0 == n) {
		// print error
		cerr << "No participants" << endl;
	} else {
		cout << "current matching: ";
		// for each pair
		for (int i = 0; i < n; i++) {
			// print out both values
			cout << "(" << matchingPairs[i].first << ","
					<< matchingPairs[i].second << ") ";
		}
		cout << endl;
	}
}

// signal handler function to stop algorithm
void signalHandler(int signal) {

	switch (signal) {
	case SIGTERM:
	case SIGINT:
	default: {
		printPairs();
		exit(EXIT_SUCCESS);
		break;
	}
	}
}

// function to create signal handlers
void createSignalHandlers() {

	// declare signal actions
	struct sigaction SigInt, SigTerm;

	// clear the structure for SIGINT
	memset(&SigInt, 0, sizeof(SigInt));

	// setup SIGINT as signalHandler and check errors
	SigInt.sa_handler = signalHandler;
	sigemptyset(&SigInt.sa_mask);
	if (-1 == sigaction(SIGINT, &SigInt, NULL)) {
		cerr << "Error assigning SIGINT\n" << endl;

	}
	// clear the structure
	memset(&SigTerm, 0, sizeof(SigTerm));

	// setup SIGTERM as signalHandler and check errors
	SigTerm.sa_handler = signalHandler;
	sigemptyset(&SigTerm.sa_mask);
	if (-1 == sigaction(SIGTERM, &SigTerm, NULL)) {
		cerr << "Error assigning SIGTERM\n" << endl;
	}
}

// CUDA kernel to create n disjoint lists over the columns of the ranking
// matrix such that
//     PE_(i,j) points to PE_(i_1,j)
// (Lu2003, 47).
__global__ void preMatch(Element *rankingMatrix, int n) {

	// if the thread is not out of bounds
	if (threadIdx.x + n < n * n) {
		// set the current PE's pointer to the next PE
		rankingMatrix[threadIdx.x].pointer =
				rankingMatrix[threadIdx.x + n].pointer;
	}
}

// CUDA kernel to swap a PE's pointer to another random PE's pointer that is in
// the same row such that
//     PE_(i,i) points to PE_(i+1,j) and
//     PE_(i,j) points to PE_(i+1,i),
//     where i <= j <= n,
// forming n new disjoint lists starting at PE_(1,j) (Lu2003, 47).
__global__ void perMatch(Element *rankingMatrix, int n, int randomOffsets[]) {

	//printf("randomOffsets[threadIdx.x]: %i\n", randomOffsets[threadIdx.x]);

	// save index of current element
	int pos1 = n * threadIdx.x + threadIdx.x;

	// save index of element in same row we are swapping with
	int pos2 = pos1 + randomOffsets[threadIdx.x];

	//printf("pos1: %i, pos2: %i\n", pos1, pos2);

	// save current pointer
	int pointer = rankingMatrix[pos1].pointer;

	// switch pointers with another element in same row
	rankingMatrix[pos1].pointer = rankingMatrix[pos2].pointer;

	// set other elements point to old pointer
	rankingMatrix[pos2].pointer = pointer;

}

// CUDA kernel to create an initial matching and store it in pairs by following
// the singly linked list (using pointer jumping) generated by perMatch(). "Each PE_(1,j) finds the
// other end PE_(n,p(1,j)) of its list where p(1,j) is the column position of
// the PE pointed to by PE_(1,j). Hence, a matching {(j,p(1,j))|1<=j<=n} is
// formed" (Lu2003, 47).
__global__ void iniMatch(Element *rankingMatrix, int n,
		thrust::pair<int, int> pairs[]) {
	// value holders for first row
	int a;
	// if we are in the first row save out pointer
	if (threadIdx.x < n) {
		// make temporary element to hold first item

		a = rankingMatrix[threadIdx.x].x; // a, as in Pair (a,b)

		// take x value for one member of pair
		pairs[threadIdx.x].first = a;
	}
	// while we are not at the end
	while (rankingMatrix[threadIdx.x].pointer < (n * n) - n) {
		// set our pointer to the pointer of the element we point to
		rankingMatrix[threadIdx.x].pointer =
				rankingMatrix[rankingMatrix[threadIdx.x].pointer].pointer;
		//printf("Thread: %i, pointer: %i\n",threadIdx.x,rankingMatrix[threadIdx.x].pointer);
	}
	// if we started in the first row save our end position
	if (threadIdx.x < n) {
		int b;
		b = rankingMatrix[rankingMatrix[threadIdx.x].pointer].x; // b, as in Pair (a,b)

		rankingMatrix[(a - 1) * n + (b - 1)].type = 1; // mark as matching

		// take the x value of the last element pointed to after following list
		// for the second member of the pair
		pairs[threadIdx.x].second = b;
		pairs[n + b - 1].second = a; // for reverse lookup
		pairs[n + b - 1].first = b; // for reverse lookup
	}
}

// CUDA kernel to mark unstable pairs in the ranking matrix
__global__ void markUnstable(Element *rankingMatrix, int n,
		thrust::pair<int, int> *pairs, bool *stable) {

	// element associated with this thread

	Element *e = &rankingMatrix[threadIdx.x];
	//printf("e: threadIdx: %2i, y: %i, x: %i\n", threadIdx.x, e.y, e.x);

	// element of matching pair in same row

	// get the current elements row
	int rowIndex = (*e).y - 1;

	// get current row in the ranking matrix
	int indexToRowInRankingMatrix = rowIndex * n;

	// get the pair in the elements rows column
	// pairs[i], 0 <= i < n, sorted by rowIndex
	int colIndex = pairs[rowIndex].second - 1;

	// index is the row shifted by the column
	int index = indexToRowInRankingMatrix + colIndex;

	Element r = rankingMatrix[index];
	//printf("r: threadIdx: %2i, y: %i, x: %i\n", threadIdx.x, r.y, r.x);

	// element of matching pair in same column

	// get the elements current column
	colIndex = (*e).x - 1;

	// get the pair in that columns row
	// pairs[i], n <= i < 2n, sorted by colIndex
	rowIndex = pairs[n + colIndex].second - 1;

	//get the row index of the pair
	indexToRowInRankingMatrix = rowIndex * n;

	// index is the row shifted by the column
	index = indexToRowInRankingMatrix + colIndex;

	Element c = rankingMatrix[index];
	//printf("c: threadIdx: %2i, y: %i, x: %i\n", threadIdx.x, c.y, c.x);

	if (r.l > (*e).l && c.r > (*e).r) {
		rankingMatrix[threadIdx.x].type = 2;
		*stable = false;
		(*e).type = 2; // mark it as unstable
		//printf("unstable pair: (%i,%i)\n", (*e).y, (*e).x);
	}
}

// CUDA kernel to gather attributes of potential nm_1-generating pairs
__global__ void protoNM1Gen(Element *rankingMatrix,
		thrust::pair<int, int> *nm1GenPairs, int n) {

	if (rankingMatrix[threadIdx.x].type == 2) { // unstable
		// take the l and col position
		nm1GenPairs[threadIdx.x].first = rankingMatrix[threadIdx.x].l;
		nm1GenPairs[threadIdx.x].second = rankingMatrix[threadIdx.x].x;
	} else {
		// set the l value to more than the max l value
		nm1GenPairs[threadIdx.x].first = n + 1;
		nm1GenPairs[threadIdx.x].second = rankingMatrix[threadIdx.x].x;
	}
}

// CUDA kernel to gather attributes of potential nm_1 pairs
__global__ void protoNM1(Element *rankingMatrix,
		thrust::pair<int, int> *nm1GenPairs, int n) {

	// get the column index in ranking matrix
	int col = (rankingMatrix[threadIdx.x].x - 1) * n;
	// get the position in column
	int shift = rankingMatrix[threadIdx.x].y - 1;
	//printf("thread: %i, shift: %i, col: %i, indexInPairs: %i\n",threadIdx.x,shift,col,col+shift);

	//if the type is nm1 gen
	if (rankingMatrix[threadIdx.x].type == 3) {

		// take the r and row position
		nm1GenPairs[col + shift].first = rankingMatrix[threadIdx.x].r;
		nm1GenPairs[col + shift].second = rankingMatrix[threadIdx.x].y;

	} else {
		// set the r value to more than the max r value
		nm1GenPairs[col + shift].first = n + 1;
		nm1GenPairs[col + shift].second = rankingMatrix[threadIdx.x].y;
	}
}

// CUDA kernel to get nm2-gen pairs
// For each PE(i,j) containing a nm1-pair mark the PE(l,k) as a nm2-generating pair,
// where l = M(C(j))x and k = M(R(i))y
__global__ void nm2Gen(Element *rankingMatrix, thrust::pair<int, int> *pairs,
		int n) {
	//if the element is of type 4
	if (rankingMatrix[threadIdx.x].type == 4) {
		// get the x-coordinate of the matching pair in column j
		int l = pairs[n + rankingMatrix[threadIdx.x].x - 1].second - 1;
		// get the y-coordinate of the matching pair in rows i
		int k = pairs[rankingMatrix[threadIdx.x].y - 1].second - 1;
		// mark element in matrix at coordinates as nm2-gen
		//printf("The values are for l: %i, k: %i, index of changed:%i, index of thread:%i\n",l,k,(n*l)+k,threadIdx.x);
		rankingMatrix[n * l + k].nm2gen = true;
	}
}

// function to print out ranking matrix L and R values
void printRankingMatrix(Element rankingMatrix[]) {

	printf("key: pair (a,b type), where type is:\n");
	printf("  0: unmatched pair\n");
	printf("  1: matched pair\n");
	printf("  2: unstable pair\n");
	printf("  3: nm1-generating-pair\n");
	printf("  4: nm1-pair\n");
	printf("  5: nm2-pair\n");

	// for each element of the ranking matrix
	for (int i = 0; i < n * n; i++) {
		// make sure i isn't out of bounds and the Y values are the same (same row)
		if ((i + 1 < n * n) && rankingMatrix[i].y == rankingMatrix[i + 1].y) {
			//  if PE is nm2gen
			if (rankingMatrix[i].nm2gen == true) {
				// print out L and R value and nm2gen symbol :
				printf("(%i,%i %i:) ", rankingMatrix[i].l, rankingMatrix[i].r,
						rankingMatrix[i].type);
			} else {

				// print out L and R value
				printf("(%i,%i %i) ", rankingMatrix[i].l, rankingMatrix[i].r,
						rankingMatrix[i].type);
			}
		}
		// otherwise print out the last PE for the row and a new line for the next row
		else {
			//  if PE is nm2gen
			if (rankingMatrix[i].nm2gen == true) {
				// print out last pair in row and start new row
				printf("(%i,%i %i:)\n", rankingMatrix[i].l, rankingMatrix[i].r,
						rankingMatrix[i].type);
			} else {

				// print out last pair in row and start new row
				printf("(%i,%i %i)\n", rankingMatrix[i].l, rankingMatrix[i].r,
						rankingMatrix[i].type);
			}
		}
	}
}

// function to print out ranking matrix pointers
void printRankingMatrixPointers(Element rankingMatrix[]) {

	// print out Ranking Matrix for checking
	for (int i = 0; i < n * n; i++) {

		// make sure i isn't out of bounds and the Y values are the same
		if ((i + 1 < n * n) && rankingMatrix[i].y == rankingMatrix[i + 1].y) {
			cout << rankingMatrix[i].pointer << " ";
		}

		// otherwise print out the last matching for row and a new line
		else {
			cout << rankingMatrix[i].pointer << endl;
		}
	}
	cout << endl;
}

// function to generate random numbers for offsets of pointer swapping
void generateRandomOffsets(int randomOffsets[]) {

	// get random seed
	srand(time(NULL));
	// for the number of random offsets we need (n-1)
	for (int i = n - 1, j = 0; i > 0; i--, j++) {

		// initialize variable for the random number
		int randInt = -1;
		do {
			// generate a random number
			randInt = (rand() % n) + 1; // 1 <= randInt <= n
		}

		// keep generating random numbers while the number isn't within range
		while (randInt > i);

		// set the random off set to the random number
		randomOffsets[j] = randInt;

		// print out the number generated
		//cout << randomOffsets[j] << " ";
	}
}

// function to generate initial match on host
void initMatch(Element rankingMatrix[]) {

	// call kernel with n^2 threads for creating disjoint lists with pointers
	preMatch<<<1, n * n>>>(rankingMatrix, n);

	// synchronize with the device
	cudaDeviceSynchronize();

	//printRankingMatrixPointers(rankingMatrix, n);

	// create array for random offsets
	int * randomOffsets;

	// allocate random offsets array on GPU
	cudaMallocManaged(&randomOffsets, (sizeof(randomOffsets[0]) * (n - 1)));

	// call function to create random numbers
	generateRandomOffsets(randomOffsets);

	// call kernel to do pointer swapping
	perMatch<<<1, n - 1>>>(rankingMatrix, n, randomOffsets);

	// synchronize with the device
	cudaDeviceSynchronize();

	//printRankingMatrixPointers(rankingMatrix, n);

	// free the random off sets on the GPU
	cudaFree(randomOffsets);

	// allocate pairs on the GPU, n for forward, n for reverse
	cudaMallocManaged(&matchingPairs, sizeof(matchingPairs[0]) * 2 * n);

	// call kernel to create initial match
	iniMatch<<<1, n * n>>>(rankingMatrix, n, matchingPairs);
	// synchronize with the device
	cudaDeviceSynchronize();
}

// function to mark the nm_1-generating pairs in the ranking matrix
void markNM1Gen(Element *rankingMatrix) {

	// make tuple of ints for pairs (lvalue, column)
	thrust::pair<int, int> *nm1GenPairs;
	cudaMallocManaged(&nm1GenPairs, sizeof(nm1GenPairs[0]) * (n * n));

	protoNM1Gen<<<1, n * n>>>(rankingMatrix, nm1GenPairs, n);
	cudaDeviceSynchronize();
	// for each row
	for (int i = 0; i < n; i++) {
		// make pointer to the minimum element in the row
		thrust::pair<int, int> *minElementInRow = thrust::min_element(
				nm1GenPairs, nm1GenPairs + n);
		// if minElementInRow is unstable
		if ((*minElementInRow).first != n + 1) {
			// change the type to nm_1-generating pair
			rankingMatrix[i * n + ((*minElementInRow).second - 1)].type = 3;
		}

		nm1GenPairs = nm1GenPairs + n;
	}

	cudaFree(nm1GenPairs);
}

// function to mark the nm_1 pairs in the ranking matrix
void markNM1(Element *rankingMatrix) {

	// make tuple of ints for pairs (lvalue, column)
	thrust::pair<int, int> *nm1Pairs;
	cudaMallocManaged(&nm1Pairs, sizeof(nm1Pairs[0]) * (n * n));

	protoNM1<<<1, n * n>>>(rankingMatrix, nm1Pairs, n);
	cudaDeviceSynchronize();
	// for each col
	for (int i = 0; i < n; i++) {
		// make pointer to the minimum element in the column
		thrust::pair<int, int> *minElementInRow = thrust::min_element(nm1Pairs,
				nm1Pairs + n);
		// if minElementInRow is unstable
		if ((*minElementInRow).first != n + 1) {
			// change the type to nm_1 pair
			//printf("The column is: %i. The second is: %i. The element is: %i\n",i+1,(*minElementInRow).second,i + (n * ((*minElementInRow).second - 1)));
			// change the pair to nm1 pair
			rankingMatrix[i + (n * ((*minElementInRow).second - 1))].type = 4;
		}

		nm1Pairs = nm1Pairs + n;
	}

	cudaFree(nm1Pairs);
}

// main function
int main(int argc, char **argv) {

	n = 0; // start with no participants

	createSignalHandlers(); // for stopping algorithm

	// check CLI arguments
	// check that the number of arguments is two
	if (argc != 2) {
		// print error and return -1
		cerr << "Incorrect number of arguments\n"
				<< "Please enter the path to the file as the first argument"
				<< endl;
		return -1;
	}

	// make a pointer to the path of the file from the CLI arguments
	const char *UsersFile;
	UsersFile = argv[1];

	/****************** Make This Section Parallel ******************/

	// make a file stream called inFile from the users file
	ifstream inFile(UsersFile);

	// make string to hold file information
	string s = "";

	// if the file exists and is open
	if (inFile) {

		// read all data into string from file
		while (inFile.good()) {

			// make a string to hold each line
			string templine;

			// get the line from the file
			getline(inFile, templine);

			// add each line to the String s
			s = s + templine;

			// increment the number of participants for each line
			n++;
		}

		// close the file stream
		inFile.close();
	}

	// print error and return -1 for error
	else {
		cerr << "File doesn't exist or couldn't be opened" << endl;
		return -1;
	}

	// make a string stream from string read from file
	stringstream ss(s);

	// divide n by 2 because we have menPrefs and womenPrefs in the same file
	n = n / 2;

	// create element pointer for Ranking Matrix
	Element *rankingMatrix;
	// allocate memory on GPU for rankingMatrix
	cudaMallocManaged(&rankingMatrix, (sizeof(*rankingMatrix) * (n * n)));

	// create ranking matrix
	// add mens prefs to the matrix by row
	// add x and y values at the same time
	// matrix is read left -> right, top -> down
	// this is generation of first arbitrary matching
	for (int i = 0, col = 0, row = 1; i < n * n; i++) {
		// initialize r Value, type and pointer
		// set r value to default to 0
		rankingMatrix[i].r = 0;

		rankingMatrix[i].type = 0; // mark unmatched
		rankingMatrix[i].nm2gen = false;
		// set the pointer to point to its element in the array
		rankingMatrix[i].pointer = i;

		// set the l value based on Mans preference
		ss >> rankingMatrix[i].l;

		// if i%n is 0 we are at the next Y position
		if (0 == i % n) {

			// increment col for a new col
			col++;
		}

		// for each col set y to that col
		rankingMatrix[i].y = col;

		// set the x value
		rankingMatrix[i].x = row;

		// if we are at the end of the matrix row
		if (row == n) {

			// reset the row
			row = 1;

		} else {

			// increment row for the next x value
			row++;
		}
	}

	// add womens prefs to the matrix by column
	for (int i = 0, colsDone = 0; i < n && colsDone < n;) {
		// read in each preference into column
		ss >> rankingMatrix[(i * n) + colsDone].r;

		// increment i
		i++;

		// if we are at the end of the column
		if (i == n) {
			// reset i
			i = 0;

			//increment the number of columns done
			colsDone++;
		}
	}
	/****************** End of Section ******************/

	// create initial matching
	initMatch(rankingMatrix);

	cudaMallocManaged(&stable, sizeof(*stable));

	*stable = true;

	// check for unstable pairs
	markUnstable<<<1, n * n>>>(rankingMatrix, n, matchingPairs, stable);

	cudaDeviceSynchronize();

	markNM1Gen(rankingMatrix);

	markNM1(rankingMatrix);

	nm2Gen<<<1, n * n>>>(rankingMatrix, matchingPairs, n);

	cudaDeviceSynchronize();

	printRankingMatrix(rankingMatrix);

	printPairs();

	cudaFree(stable);
	cudaFree(matchingPairs);
	cudaFree(rankingMatrix);

	/****************** Reset And End ******************/
	// cudaDeviceReset causes the driver to clean up all state. While
	// not mandatory in normal operation, it is good practice.  It is also
	// needed to ensure correct operation when the application is being
	// profiled. Calling cudaDeviceReset causes all profile data to be
	// flushed before the application exits -nvidia
	cudaDeviceReset();

	// return 0 for successful completion of the program
	return 0;
}
