// for cout
#include <iostream>
// for signal handlers
#include <signal.h>
// for string stream after reading from file
#include <sstream>
// for file stream
#include <fstream>
// c++ STL for string
#include <string>
// for printf()
#include <cstdio>
// for time()
#include <time.h>
// for sleep()
#include <unistd.h>
// for thrust::min_element()
#include <thrust/extrema.h>

using namespace std;

//struct compare_key_value {
//	__host__ __device__
//	bool operator()(thrust::pair<int, int> lhs, thrust::pair<int, int> rhs) {
//		return lhs.first < rhs.first;
//	}
//};

// structure for each Processor Element
struct Element {
	// graph x value, column
	int x;
	// graph y value, row
	int y;
	// l value of the graph (e.g., man pref)
	int l;
	// r value of the graph (e.g., women pref)
	int r;
	// logical pointer to element
	int pointer;
	// type of the pair
	//   0: unmatched
	//   1: matched
	//   2: unstable
	//   3: nm_1-generating
	//   4: nm_1
	//   5: nm-2-generating
	//   6: nm-2
	int type;
};

// structure to represent a pair
struct Pair {
	int a; // integer to hold element a, e.g. the man, 1 <= a <= n
	int b; // integer to hold element b, e.g. the woman, 1 <= a <= n
};

Pair *matchingPairs;

// global state for stable matching
// true if no unstable matches exist, false otherwise
bool *stable;

// global counter for the number of lines/people
int n;

// function for printing pairs
void printPairs() {

	// check that n isn't 0
	if (0 == n) {
		// print error
		cerr << "No participants" << endl;
	} else {
		cout << "current matching: ";
		// for each pair
		for (int i = 0; i < n; i++) {
			// print out both values
			cout << "(" << matchingPairs[i].a << "," << matchingPairs[i].b
					<< ") ";
		}
		cout << endl;
	}
}

// signal handler function to stop algorithm
void signalHandler(int signal) {

	switch (signal) {
	case SIGTERM:
	case SIGINT:
	default: {
		printPairs();
		exit(EXIT_SUCCESS);
		break;
	}
	}
}

// function to create signal handlers
void createSignalHandlers() {

	// declare signal actions
	struct sigaction SigInt, SigTerm;

	// clear the structure for SIGINT
	memset(&SigInt, 0, sizeof(SigInt));

	// setup SIGINT as signalHandler and check errors
	SigInt.sa_handler = signalHandler;
	sigemptyset(&SigInt.sa_mask);
	if (-1 == sigaction(SIGINT, &SigInt, NULL)) {
		cerr << "Error assigning SIGINT\n" << endl;

	}
	// clear the structure
	memset(&SigTerm, 0, sizeof(SigTerm));

	// setup SIGTERM as signalHandler and check errors
	SigTerm.sa_handler = signalHandler;
	sigemptyset(&SigTerm.sa_mask);
	if (-1 == sigaction(SIGTERM, &SigTerm, NULL)) {
		cerr << "Error assigning SIGTERM\n" << endl;
	}
}

// CUDA kernel to create n disjoint lists over the columns of the ranking
// matrix such that
//     PE_(i,j) points to PE_(i_1,j)
// (Lu2003, 47).
__global__ void preMatch(Element *rankingMatrix, int n) {

	// if the thread is not out of bounds
	if (threadIdx.x + n < n * n) {
		// set the current PE's pointer to the next PE
		rankingMatrix[threadIdx.x].pointer =
				rankingMatrix[threadIdx.x + n].pointer;
	}
}

// CUDA kernel to swap a PE's pointer to another random PE's pointer that is in
// the same row such that
//     PE_(i,i) points to PE_(i+1,j) and
//     PE_(i,j) points to PE_(i+1,i),
//     where i <= j <= n,
// forming n new disjoint lists starting at PE_(1,j) (Lu2003, 47).
__global__ void perMatch(Element *rankingMatrix, int n, int randomOffsets[]) {

	//printf("randomOffsets[threadIdx.x]: %i\n", randomOffsets[threadIdx.x]);

	// save index of current element
	int pos1 = n * threadIdx.x + threadIdx.x;

	// save index of element in same row we are swapping with
	int pos2 = pos1 + randomOffsets[threadIdx.x];

	//printf("pos1: %i, pos2: %i\n", pos1, pos2);

	// save current pointer
	int pointer = rankingMatrix[pos1].pointer;

	// switch pointers with another element in same row
	rankingMatrix[pos1].pointer = rankingMatrix[pos2].pointer;

	// set other elements point to old pointer
	rankingMatrix[pos2].pointer = pointer;

}

// CUDA kernel to create an initial matching and store it in pairs by following
// the singly linked list generated by perMatch(). "Each PE_(1,j) finds the
// other end PE_(n,p(1,j)) of its list where p(1,j) is the column position of
// the PE pointed to by PE_(1,j). Hence, a matching {(j,p(1,j))|1<=j<=n} is
// formed" (Lu2003, 47).
__global__ void iniMatch(Element *rankingMatrix, int n, Pair pairs[]) {

	// make temporary element to hold first item
	Element e = rankingMatrix[threadIdx.x];

	int a = e.x; // a, as in Pair (a,b)

	// take x value for one member of pair
	pairs[threadIdx.x].a = a;

	// go to the end of the list
	for (int i = 0; i < n - 1; i++) {

		//change element to what each element points to
		e = rankingMatrix[e.pointer];
	}

	int b = e.x; // b, as in Pair (a,b)

	rankingMatrix[(a - 1) * n + (b - 1)].type = 1; // mark as matching

	// take the x value of the last element pointed to after following list
	// for the second member of the pair
	pairs[threadIdx.x].b = b;
	pairs[n + b - 1].b = a; // for reverse lookup
	pairs[n + b - 1].a = b; // for reverse lookup
}

// CUDA kernel to mark unstable pairs in the ranking matrix
__global__ void markUnstable(Element *rankingMatrix, int n, Pair *pairs,
		bool *stable) {

	// element associated with this thread

	Element *e = &rankingMatrix[threadIdx.x];
	//printf("e: threadIdx: %2i, y: %i, x: %i\n", threadIdx.x, e.y, e.x);

	// element of matching pair in same row

	// get the current elements row
	int rowIndex = (*e).y - 1;

	// get current row in the ranking matrix
	int indexToRowInRankingMatrix = rowIndex * n;

	// get the pair in the elements rows column
	// pairs[i], 0 <= i < n, sorted by rowIndex
	int colIndex = pairs[rowIndex].b - 1;

	// index is the row shifted by the column
	int index = indexToRowInRankingMatrix + colIndex;

	Element r = rankingMatrix[index];
	//printf("r: threadIdx: %2i, y: %i, x: %i\n", threadIdx.x, r.y, r.x);

	// element of matching pair in same column

	// get the elements current column
	colIndex = (*e).x - 1;

	// get the pair in that columns row
	// pairs[i], n <= i < 2n, sorted by colIndex
	rowIndex = pairs[n + colIndex].b - 1;

	//get the row index of the pair
	indexToRowInRankingMatrix = rowIndex * n;

	// index is the row shifted by the column
	index = indexToRowInRankingMatrix + colIndex;

	Element c = rankingMatrix[index];
	//printf("c: threadIdx: %2i, y: %i, x: %i\n", threadIdx.x, c.y, c.x);

	if (r.l > (*e).l && c.r > (*e).r) {
		rankingMatrix[threadIdx.x].type = 2;
		*stable = false;
		(*e).type = 2; // mark it as unstable
		//printf("unstable pair: (%i,%i)\n", (*e).y, (*e).x);
	}
}

// CUDA kernel to gather attributes of potential nm_1-generating pairs
__global__ void protoNM1Gen(
		Element *rankingMatrix,
		thrust::pair<int, int> *nm1GenPairs,
		int n) {

	if (rankingMatrix[threadIdx.x].type == 2) { // unstable
		// take the l and col position
		nm1GenPairs[threadIdx.x].first = rankingMatrix[threadIdx.x].l;
		nm1GenPairs[threadIdx.x].second = rankingMatrix[threadIdx.x].x;
	} else {
		// set the l value to more than the max l value
		nm1GenPairs[threadIdx.x].first = n + 1;
		nm1GenPairs[threadIdx.x].second = rankingMatrix[threadIdx.x].x;
	}
}

// function to print out ranking matrix L and R values
void printRankingMatrix(Element rankingMatrix[]) {

	printf("key: pair (a,b type), where type is:\n");
	printf("  0: unmatched pair\n");
	printf("  1: matched pair\n");
	printf("  2: unstable pair\n");
	printf("  3: nm1-generating-pair\n");
	printf("  4: nm1-pair\n");
	printf("  5: nm2-generating-pair\n");
	printf("  6: nm1-pair\n");

	// for each element of the ranking matrix
	for (int i = 0; i < n * n; i++) {
		// make sure i isn't out of bounds and the Y values are the same (same row)
		if ((i + 1 < n * n) && rankingMatrix[i].y == rankingMatrix[i + 1].y) {
			// print out L and R value
			printf("(%i,%i %i) ", rankingMatrix[i].l, rankingMatrix[i].r,
					rankingMatrix[i].type);
		}
		// otherwise print out the last PE for the row and a new line for the next row
		else {
			// print out last pair in row and start new row
			printf("(%i,%i %i)\n", rankingMatrix[i].l, rankingMatrix[i].r,
					rankingMatrix[i].type);
		}
	}
}

// function to print out ranking matrix pointers
void printRankingMatrixPointers(Element rankingMatrix[]) {

	// print out Ranking Matrix for checking
	for (int i = 0; i < n * n; i++) {

		// make sure i isn't out of bounds and the Y values are the same
		if ((i + 1 < n * n) && rankingMatrix[i].y == rankingMatrix[i + 1].y) {
			cout << rankingMatrix[i].pointer << " ";
		}

		// otherwise print out the last matching for row and a new line
		else {
			cout << rankingMatrix[i].pointer << endl;
		}
	}
	cout << endl;
}

// function to generate random numbers for offsets of pointer swapping
void generateRandomOffsets(int randomOffsets[]) {

	//TODO: Use cuRand for random number generation

	// get random seed
	srand(time(NULL));

	// for the number of random offsets we need (n-1)
	for (int i = n - 1, j = 0; i > 0; i--, j++) {

		// initialize variable for the random number
		int randInt = -1;
		do {
			// generate a random number
			randInt = (rand() % n) + 1; // 1 <= randInt <= n
		}

		// keep generating random numbers while the number isn't within range
		while (randInt > i);

		// set the random off set to the random number
		randomOffsets[j] = randInt;

		// print out the number generated
		//cout << randomOffsets[j] << " ";
	}
}

// function to generate initial match on host
void initMatch(Element rankingMatrix[]) {

	// call kernel with n^2 threads for creating disjoint lists with pointers
	preMatch<<<1, n * n>>>(rankingMatrix, n);

	// synchronize with the device
	cudaDeviceSynchronize();

	//printRankingMatrixPointers(rankingMatrix, n);

	// create array for random offsets
	int * randomOffsets;

	// allocate random offsets array on GPU
	cudaMallocManaged(&randomOffsets, (sizeof(randomOffsets[0]) * (n - 1)));

	// call function to create random numbers
	generateRandomOffsets(randomOffsets);

	// call kernel to do pointer swapping
	perMatch<<<1, n - 1>>>(rankingMatrix, n, randomOffsets);

	// synchronize with the device
	cudaDeviceSynchronize();

	//printRankingMatrixPointers(rankingMatrix, n);

	// free the random off sets on the GPU
	cudaFree(randomOffsets);

	// allocate pairs on the GPU, n for forward, n for reverse
	cudaMallocManaged(&matchingPairs, sizeof(matchingPairs[0]) * 2 * n);

	// call kernel to create initial match
	iniMatch<<<1, n>>>(rankingMatrix, n, matchingPairs);

	// synchronize with the device
	cudaDeviceSynchronize();
}

// function to mark the nm_1-generating pairs in the ranking matrix
void markNM1Gen(Element *rankingMatrix) {

	// make tuple of ints for pairs (lvalue, column)
	thrust::pair<int, int> *nm1GenPairs;
	cudaMallocManaged(&nm1GenPairs, sizeof(nm1GenPairs[0]) * (n * n));

	protoNM1Gen<<<1, n * n>>>(rankingMatrix, nm1GenPairs, n);
	cudaDeviceSynchronize();

	// for each row
	for (int i = 0; i < n; i++) {
		// make pointer to the minimum element in the row
		thrust::pair<int, int> *minElementInRow =
				thrust::min_element(nm1GenPairs, nm1GenPairs + n);
		// if minElementInRow is unstable
		if ((*minElementInRow).first != n + 1) {
			// change the type to nm_1-generating pair
			rankingMatrix[i * n + ((*minElementInRow).second - 1)].type = 3;
		}

		nm1GenPairs = nm1GenPairs + n;
	}

	cudaFree(nm1GenPairs);
}

int main(int argc, char **argv) {

	n = 0; // start with no participants

	createSignalHandlers(); // for stopping algorithm

	// check CLI arguments
	// check that the number of arguments is two
	if (argc != 2) {
		// print error and return -1
		cerr << "Incorrect number of arguments\n"
				<< "Please enter the path to the file as the first argument"
				<< endl;
		return -1;
	}

	/****************** Read In File For Data ******************/

	// make a pointer to the path of the file from the CLI arguments
	const char *UsersFile;
	UsersFile = argv[1];

	// make a file stream called inFile from the users file
	ifstream inFile(UsersFile);

	// make string to hold file information
	string s = "";

	// if the file exists and is open
	if (inFile) {

		// read all data into string from file
		while (inFile.good()) {

			// make a string to hold each line
			string templine;

			// get the line from the file
			getline(inFile, templine);

			// add each line to the String s
			s = s + templine;

			// increment the number of participants for each line
			n++;
		}

		// close the file stream
		inFile.close();
	}

	// print error and return -1 for error
	else {
		cerr << "File doesn't exist or couldn't be opened" << endl;
		return -1;
	}

	/****************** End Of File Reading ******************/

	// make a string stream from string read from file
	stringstream ss(s);

	// divide n by 2 because we have menPrefs and womenPrefs in the same file
	n = n / 2;

	// create element pointer for Ranking Matrix
	Element *rankingMatrix;

	// allocate memory on GPU for rankingMatrix
	cudaMallocManaged(&rankingMatrix, (sizeof(*rankingMatrix) * (n * n)));

	//TODO: Move creation of Matrix to CUDA
	// create ranking matrix
	// add mens prefs to the matrix by row
	// add x and y values at the same time
	// matrix is read left -> right, top -> down
	// this is generation of first arbitrary matching
	for (int i = 0, col = 0, row = 1; i < n * n; i++) {
		// initialize r Value, type and pointer
		// set r value to default to 0
		rankingMatrix[i].r = 0;

		rankingMatrix[i].type = 0; // mark unmatched

		// set the pointer to point to its element in the array
		rankingMatrix[i].pointer = i;

		// set the l value based on Mans preference
		ss >> rankingMatrix[i].l;

		// if i%n is 0 we are at the next Y position
		if (0 == i % n) {

			// increment col for a new col
			col++;
		}

		// for each col set y to that col
		rankingMatrix[i].y = col;

		// set the x value
		rankingMatrix[i].x = row;

		// if we are at the end of the matrix row
		if (row == n) {

			// reset the row
			row = 1;

		} else {

			// increment row for the next x value
			row++;
		}
	}

	// add womens prefs to the matrix by column
	for (int i = 0, colsDone = 0; i < n && colsDone < n;) {
		// read in each preference into column
		ss >> rankingMatrix[(i * n) + colsDone].r;

		// increment i
		i++;

		// if we are at the end of the column
		if (i == n) {
			// reset i
			i = 0;

			//increment the number of columns done
			colsDone++;
		}
	}

	// create initial matching
	initMatch(rankingMatrix);

	cudaMallocManaged(&stable, sizeof(*stable));

	*stable = true;

	// check for unstable pairs
	markUnstable<<<1, n * n>>>(rankingMatrix, n, matchingPairs, stable);

	cudaDeviceSynchronize();

	markNM1Gen(rankingMatrix);

	printRankingMatrix(rankingMatrix);

	while (!*stable) {
		//iterate<<<1, n>>>(rankingMatrix, n, pairs);
		//markUnstable<<<1, n * n>>>(rankingMatrix, n, pairs, stable);
		//cudaDeviceSynchronize();
		sleep(1); // take a nap, not a coma
	}

	printPairs();

	cudaFree(stable);
	cudaFree(matchingPairs);
	cudaFree(rankingMatrix);

	/****************** Reset And End ******************/
	// cudaDeviceReset causes the driver to clean up all state. While
	// not mandatory in normal operation, it is good practice.  It is also
	// needed to ensure correct operation when the application is being
	// profiled. Calling cudaDeviceReset causes all profile data to be
	// flushed before the application exits -nvidia
	cudaDeviceReset();

	// return 0 for successful completion of the program
	return 0;
}
